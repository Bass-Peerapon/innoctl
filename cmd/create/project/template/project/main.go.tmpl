package main

import (
	"context"
	"fmt"
	"git.innovasive.co.th/backend/psql"
	"github.com/MicahParks/keyfunc/v3"
	"github.com/getsentry/sentry-go"
	sentryecho "github.com/getsentry/sentry-go/echo"
	"github.com/labstack/echo/v4"
	echoMiddL "github.com/labstack/echo/v4/middleware"
	"github.com/opentracing/opentracing-go"
	"github.com/spf13/cast"
	"google.golang.org/grpc"
	"log/slog"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"time"
	myMiddL "{{.ModuleName}}/middleware"
	helperGRPC "{{.ModuleName}}/utils/grpc"
	"{{.ModuleName}}/utils/helper"
	_util_tracing "{{.ModuleName}}/utils/opentracing"
)

var (
	grpcMaxReceiveSize = (1024 * 1024) * cast.ToInt(helper.GetENV("GRPC_MAX_RECEIVE_SIZE", "4"))
)

var (
	APP_PORT                = helper.GetENV("APP_PORT", "3000")
	GRPC_PORT               = helper.GetENV("GRPC_PORT", "3100")
	ALLOW_ORIGIN            = strings.Split(helper.GetENV("ALLOW_ORIGIN", "*"), ",")
	ALLOW_ORIGIN_HEADER     = strings.Split(helper.GetENV("ALLOW_ORIGIN_HEADER", ""), ",")
	ALLOW_ORIGIN_CREDENTIAL = cast.ToBool(helper.GetENV("ALLOW_ORIGIN_CREDENTIAL", "false"))
	PSQL_DATABASE_URL       = helper.GetENV("PSQL_DATABASE_URL", "postgres://postgres:postgres@psql_db:5432/app_example?sslmode=disable")
	SENTRY_DSN              = helper.GetENV("SENTRY_DSN", "")
	JAEGER_SERVICE_NAME     = helper.GetENV("JAEGER_SERVICE_NAME", "")
	JWKS_URL                = strings.Split(helper.GetENV("JWKS_URL", ""), ",")
)

func sqlDBWithTracing(con string, tracer opentracing.Tracer) *psql.Client {
	db, err := psql.NewConnectionWithTracing(con, psql.Postgres, tracer)
	if err != nil {
		panic(err)
	}
	return db
}

func main() {
	// /* init sentry */
	sentryErr := sentry.Init(sentry.ClientOptions{
		Dsn: SENTRY_DSN,
	})
	// /* init tracing*/
	tracer, closer := _util_tracing.Init("{{.ProjectName}}")
	defer closer.Close()
	opentracing.SetGlobalTracer(tracer)

	psqlClient := sqlDBWithTracing(PSQL_DATABASE_URL, tracer)
	defer psqlClient.GetClient().Close()

	// /* init grpc */
	server := helperGRPC.NewServer(JAEGER_SERVICE_NAME, SENTRY_DSN, grpc.MaxRecvMsgSize(grpcMaxReceiveSize))
	defer server.GracefulStop()

	e := echo.New()
	logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
	e.Use(myMiddL.Logger(logger))
	e.Use(echoMiddL.Recover())
	e.Use(sentryecho.New(sentryecho.Options{Repanic: true}))
	e.Use(echoMiddL.CORSWithConfig(echoMiddL.CORSConfig{
		Skipper:          echoMiddL.DefaultSkipper,
		AllowOrigins:     ALLOW_ORIGIN,
		AllowHeaders:     ALLOW_ORIGIN_HEADER,
		AllowMethods:     []string{http.MethodGet, http.MethodHead, http.MethodOptions, http.MethodPut, http.MethodPatch, http.MethodPost, http.MethodDelete},
		AllowCredentials: ALLOW_ORIGIN_CREDENTIAL,
	}))
	middL := myMiddL.InitMiddleware()
	e.Use(middL.SetTracer)
	e.Use(middL.TransformResponse)
	e.HTTPErrorHandler = myMiddL.SentryCapture(e)

	e.GET("/", func(c echo.Context) error {
		return c.String(http.StatusOK, "Hello, World!")
	})
	e.GET("/health-check", func(c echo.Context) error {
		// NOTE: add db health check like example below
		// DBStat := psqlClient.GetClient().Stats()
		// db := echo.Map{
		// 	"postgres": echo.Map{
		// 		"dbname": echo.Map{
		// 			"open_connections":     DBStat.OpenConnections,
		// 			"in_use":               DBStat.InUse,
		// 			"idle":                 DBStat.Idle,
		// 			"wait_count":           DBStat.WaitCount,
		// 			"wait_duration":        DBStat.WaitDuration.String(),
		// 			"max_open_connections": DBStat.MaxOpenConnections,
		// 			"max_idle_closed":      DBStat.MaxIdleClosed,
		// 			"max_idle_time_closed": DBStat.MaxIdleTimeClosed,
		// 			"max_lifetime_closed":  DBStat.MaxLifetimeClosed,
		// 		},
		// 	},
		// }
		resp := echo.Map{
			"status": "ok",
			// "db":     db,
		}
		return c.JSON(http.StatusOK, resp)
	})
	e.GET("/version", func(c echo.Context) error {
		goVersion := helper.GetENV("GOLANG_VERSION", "not found env on key 'GOLANG_VERSION'")
		buildNumber := helper.GetENV("env_build_number", "not found env on key 'env_build_number'")
		version := helper.GetENV("env_version", "not found env on key 'env_version'")
		return c.JSON(http.StatusOK, echo.Map{
			"go_version":   goVersion,
			"build_number": buildNumber,
			"version":      version,
		})
	})

	jwks, err := keyfunc.NewDefault(JWKS_URL)
	if err != nil {
		panic(err)
	}

	mw, err := myMiddL.CreateOpenapiMiddleware(
		jwks,
		nil,
	)
	if err != nil {
		panic(err)
	}
	e.Use(mw)

	/* repository */

	/* usecase */

	/* handler */

	/* gprc handler */

	/* inject route */

	/* inject grpc route */

	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
	defer stop()

	/* serve gprc */
	go func() {
		if r := recover(); r != nil {
			fmt.Println("error on start grpc server: ", r.(error))
		}
		startGRPCServer(server)
	}()

	go func() {
		/* serve echo */
		port := fmt.Sprintf(":%s", APP_PORT)
		if sentryErr == nil {
			sentry.CaptureException(e.Start(port))
		} else {
			e.Logger.Fatal(e.Start(port))
		}
	}()

	<-ctx.Done()
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	if err := e.Shutdown(ctx); err != nil {
		e.Logger.Fatal(err)
	}
}

func startGRPCServer(server *grpc.Server) {
	listen, err := net.Listen("tcp", fmt.Sprintf(":%s", GRPC_PORT))
	if err != nil {
		panic("failed to listen: " + err.Error())
	}

	/* serve grpc */
	fmt.Printf("Start grpc Server [::%s]\n", GRPC_PORT)
	if err := server.Serve(listen); err != nil {
		panic(err)
	}
}
