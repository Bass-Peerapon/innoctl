package middleware

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/MicahParks/keyfunc/v3"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/getkin/kin-openapi/openapi3filter"
	"github.com/labstack/echo/v4"
	middleware "github.com/oapi-codegen/echo-middleware"
)

const JWTClaimsContextKey = "payload"

var (
	ErrNoAuthHeader        = errors.New("Authorization header is missing")
	ErrInvalidAuthHeader   = errors.New("Authorization header is malformed")
	ErrClaimsInvalid       = errors.New("Provided claims do not match expected scopes")
	ErrUserSessionNotFound = errors.New(
		"User session not found or doesn't have client attached on it",
	)
	ErrIssuerNotFound    = errors.New("Issuer not found")
	ErrrPermissionDenied = errors.New("Permission denied")
)

type PermValidator interface {
	CheckPermission(ctx context.Context, id string, perms []string) (bool, error)
}

func CreateOpenapiMiddleware(
	jwks keyfunc.Keyfunc,
	permValidator PermValidator,
	getSwaggers ...func() (*openapi3.T, error),
) (echo.MiddlewareFunc, error) {
	validators := make([]echo.MiddlewareFunc, 0, len(getSwaggers))

	for _, getSwagger := range getSwaggers {
		spec, err := getSwagger()
		if err != nil {
			return nil, err
		}
		validator := middleware.OapiRequestValidatorWithOptions(spec, &middleware.Options{
			Options: openapi3filter.Options{
				AuthenticationFunc: NewAuthenticator(jwks, permValidator),
			},
			Skipper: func(c echo.Context) bool {
				return c.Path() == "/" || c.Path() == "/health-check"
			},
			ErrorHandler: func(c echo.Context, err *echo.HTTPError) error {
				if err != nil && err.Code == http.StatusNotFound {
					return echo.NewHTTPError(http.StatusNotFound, err.Message)
				}
				return err
			},
			SilenceServersWarning: true,
		})
		validators = append(validators, validator)
	}

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			var matched bool
			var err error
			for _, v := range validators {
				// ใช้ middleware ตรวจเฉย ๆ ด้วย dummy handler
				err = v(func(c echo.Context) error {
					matched = true
					return nil
				})(c)

				if err == nil && matched {
					break
				}
				if !strings.Contains(err.Error(), "no matching operation was found") {
					if strings.Contains(err.Error(), "code=401") {
						return echo.NewHTTPError(http.StatusUnauthorized, err.Error())
					}
					return NewMultiErrorHandler(err)
				}

			}

			if !matched && err != nil {
				if !strings.Contains(err.Error(), "no matching operation was found") {
					if strings.Contains(err.Error(), "code=401") {
						return echo.NewHTTPError(http.StatusUnauthorized, err.Error())
					}
					return NewMultiErrorHandler(err)
				}
			}
			return next(c)
		}
	}, nil
}

func NewMultiErrorHandler(err error) *echo.HTTPError {
	if he, ok := err.(*echo.HTTPError); ok {
		switch he.Internal.(type) {
		case *openapi3filter.RequestError:
			e := he.Internal.(*openapi3filter.RequestError)
			return echo.NewHTTPError(http.StatusBadRequest, e.Err)
		default:
			return echo.NewHTTPError(http.StatusBadRequest, he.Error())
		}

	}
	return echo.NewHTTPError(http.StatusBadRequest, err.Error())
}

// GetJWSFromRequest extracts a JWS string from an Authorization: Bearer <jws> header
func GetJWSFromRequest(req *http.Request) (string, error) {
	authHdr := req.Header.Get("Authorization")
	// Check for the Authorization header.
	if authHdr == "" {
		return "", ErrNoAuthHeader
	}
	// We expect a header value of the form "Bearer <token>", with 1 space after
	// Bearer, per spec.
	prefix := "Bearer "
	if !strings.HasPrefix(authHdr, prefix) {
		return "", ErrInvalidAuthHeader
	}
	return strings.TrimPrefix(authHdr, prefix), nil
}

func NewAuthenticator(
	jwks keyfunc.Keyfunc,
	permValidator PermValidator,
) openapi3filter.AuthenticationFunc {
	return func(ctx context.Context, input *openapi3filter.AuthenticationInput) error {
		return Authenticate(jwks, permValidator, ctx, input)
	}
}

// Authenticate uses the specified validator to ensure a JWT is valid, then makes
// sure that the claims provided by the JWT match the scopes as required in the API.
func Authenticate(
	jwks keyfunc.Keyfunc,
	permValidator PermValidator,
	ctx context.Context,
	input *openapi3filter.AuthenticationInput,
) error {
	// Our security scheme is named BearerAuth, ensure this is the case
	if input.SecuritySchemeName != "BearerAuth" {
		return echo.NewHTTPError(http.StatusUnauthorized, fmt.Errorf("security scheme %s != 'BearerAuth'", input.SecuritySchemeName))
	}

	// Now, we need to get the JWS from the request, to match the request expectations
	// against request contents.
	jws, err := GetJWSFromRequest(input.RequestValidationInput.Request)
	if err != nil {
		return echo.NewHTTPError(http.StatusUnauthorized, fmt.Errorf("getting jws: %w", err))
	}

	claims, err := ValidateToken(jws, jwks)
	if err != nil {
		return echo.NewHTTPError(http.StatusUnauthorized, fmt.Errorf("validating token: %w", err))
	}

	// Check if token is expired
	if claims.ExpiresAt != nil && claims.ExpiresAt.Time.Before(time.Now()) {
		return echo.NewHTTPError(http.StatusUnauthorized, errors.New("token is expired"))
	}

	if len(input.Scopes) != 0 {
		if permValidator != nil {
			//NOTE: can change id to your own id
			valid, err := permValidator.CheckPermission(ctx, claims.Username, input.Scopes)
			if err != nil {
				return echo.NewHTTPError(http.StatusUnauthorized, fmt.Errorf("check permission: %w", err))
			}

			if !valid {
				return echo.NewHTTPError(http.StatusUnauthorized, ErrrPermissionDenied)
			}
		}
	}

	eCtx := middleware.GetEchoContext(ctx)
	eCtx.Set(JWTClaimsContextKey, claims)

	return nil
}
