package middleware

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"
	"{{.ModuleName}}/response"
	"github.com/MicahParks/keyfunc/v3"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/getkin/kin-openapi/openapi3filter"
	"github.com/labstack/echo/v4"
	middleware "github.com/oapi-codegen/echo-middleware"
)

const JWTClaimsContextKey = "payload"

var (
	ErrNoAuthHeader        = errors.New("Authorization header is missing")
	ErrInvalidAuthHeader   = errors.New("Authorization header is malformed")
	ErrClaimsInvalid       = errors.New("Provided claims do not match expected scopes")
	ErrUserSessionNotFound = errors.New(
		"User session not found or doesn't have client attached on it",
	)
	ErrIssuerNotFound    = errors.New("Issuer not found")
	ErrrPermissionDenied = errors.New("Permission denied")
)

func init() {
	openapi3.SchemaErrorDetailsDisabled = true
}

type PermValidator interface {
	CheckPermission(ctx context.Context, id string, perms []string) (bool, error)
}

func CreateOpenapiMiddleware(
	jwks keyfunc.Keyfunc,
	permValidator PermValidator,
	getSwaggers ...func() (*openapi3.T, error),
) (echo.MiddlewareFunc, error) {
	validators := make([]echo.MiddlewareFunc, 0, len(getSwaggers))

	for _, getSwagger := range getSwaggers {
		spec, err := getSwagger()
		if err != nil {
			return nil, err
		}
		validator := middleware.OapiRequestValidatorWithOptions(spec, &middleware.Options{
			Options: openapi3filter.Options{
				AuthenticationFunc: NewAuthenticator(jwks, permValidator),
				MultiError:         true,
			},
			Skipper: func(c echo.Context) bool {
				return c.Path() == "/" || c.Path() == "/health-check"
			},
			ErrorHandler: func(c echo.Context, err *echo.HTTPError) error {
				if err != nil && err.Code == http.StatusNotFound {
					return echo.NewHTTPError(http.StatusNotFound, err.Message)
				}
				return err
			},
			SilenceServersWarning: true,
		})
		validators = append(validators, validator)
	}

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			var matched bool
			var err error
			for _, v := range validators {
				// ใช้ middleware ตรวจเฉย ๆ ด้วย dummy handler
				err = v(func(c echo.Context) error {
					matched = true
					return nil
				})(c)

				if err == nil && matched {
					break
				}
				if !strings.Contains(err.Error(), "no matching operation was found") {
					return NewMultiErrorHandler(err)
				}

			}

			if !matched && err != nil {
				if !strings.Contains(err.Error(), "no matching operation was found") {
					return NewMultiErrorHandler(err)
				}
			}
			return next(c)
		}
	}, nil
}

type DataResponseError struct {
	Field   string  `json:"field"`
	In      *string `json:"in,omitempty"`
	Message string  `json:"message"`
}

func NewMultiErrorHandler(err error) response.Response {
	if authErr, ok := err.(AuthError); ok {
		return response.NewResponseError(http.StatusUnauthorized, response.RESPONSE_CODE_UNAUTHORIZE, authErr.Message, nil)
	}
	if he, ok := err.(*echo.HTTPError); ok {
		switch internalErr := he.Internal.(type) {
		// ---- Single Error from Request Validation ----
		case *openapi3filter.RequestError:
			reason := ""
			if internalErr.Err != nil {
				reason = internalErr.Err.Error()
			}
			if internalErr.Parameter != nil {
				reason = fmt.Sprintf("parameter %q in %s has an error: %s", internalErr.Parameter.Name, internalErr.Parameter.In, reason)
			} else if internalErr.RequestBody != nil {
				reason = fmt.Sprintf("request body has an error: %s", reason)
			}
			return response.NewResponseError(http.StatusBadRequest, response.RESPONSE_CODE_INVALID_ARGUMENT, reason, nil)
		// ---- Multiple Errors (MultiError) ----
		case openapi3.MultiError:
			data := []DataResponseError{}
			reasons := []string{}
			for _, e := range internalErr {
				if reqErr, ok := e.(*openapi3filter.RequestError); ok {
					reason := ""
					if reqErr.Err != nil {
						reason = reqErr.Err.Error()
					}
					field := ""
					message := ""
					var in *string
					if reqErr.Parameter != nil {
						reason = fmt.Sprintf("parameter %q in %s has an error: %s", reqErr.Parameter.Name, reqErr.Parameter.In, reason)
						field = reqErr.Parameter.Name
						in = &reqErr.Parameter.In
						message = reason
						reasons = append(reasons, reason)
						data = append(data, DataResponseError{
							Field:   field,
							In:      in,
							Message: message,
						})
					} else if reqErr.RequestBody != nil {
						reason = fmt.Sprintf("request body has an error: %s", reason)
						reasons = append(reasons, reason)
						if reqErr.Err != nil {
							if multiErr, ok := reqErr.Err.(openapi3.MultiError); ok {
								for _, err := range multiErr {
									if schemaErr, ok := err.(*openapi3.SchemaError); ok {
										if len(schemaErr.JSONPointer()) > 0 {
											field = strings.Join(schemaErr.JSONPointer(), "/")
										}
										message = schemaErr.Reason
										if schemaErr.Origin != nil {
											message = schemaErr.Origin.Error()
										}
									}
									data = append(data, DataResponseError{
										Field:   field,
										In:      in,
										Message: message,
									})
								}
							}
						}
					}

				} else if secErr, ok := e.(*openapi3filter.SecurityRequirementsError); ok {
					for _, err := range secErr.Errors {
						if authErr, ok := err.(AuthError); ok {
							return response.NewResponseError(http.StatusUnauthorized, response.RESPONSE_CODE_UNAUTHORIZE, authErr.Message, nil)
						}

					}
					return response.NewResponseError(http.StatusUnauthorized, response.RESPONSE_CODE_UNAUTHORIZE, secErr.Error(), nil)
				}
			}
			return response.NewResponseError(http.StatusBadRequest, response.RESPONSE_CODE_INVALID_ARGUMENT, strings.Join(reasons, " | "), data)

		}

	}
	return response.NewResponseError(http.StatusBadRequest, response.RESPONSE_CODE_INVALID_ARGUMENT, err.Error(), nil)
}

type AuthError struct {
	Message string
}

func (e AuthError) Error() string {
	return e.Message
}

// GetJWSFromRequest extracts a JWS string from an Authorization: Bearer <jws> header
func GetJWSFromRequest(req *http.Request) (string, error) {
	authHdr := req.Header.Get("Authorization")
	// Check for the Authorization header.
	if authHdr == "" {
		return "", ErrNoAuthHeader
	}
	// We expect a header value of the form "Bearer <token>", with 1 space after
	// Bearer, per spec.
	prefix := "Bearer "
	if !strings.HasPrefix(authHdr, prefix) {
		return "", ErrInvalidAuthHeader
	}
	return strings.TrimPrefix(authHdr, prefix), nil
}

func NewAuthenticator(
	jwks keyfunc.Keyfunc,
	permValidator PermValidator,
) openapi3filter.AuthenticationFunc {
	return func(ctx context.Context, input *openapi3filter.AuthenticationInput) error {
		return Authenticate(jwks, permValidator, ctx, input)
	}
}

// Authenticate uses the specified validator to ensure a JWT is valid, then makes
// sure that the claims provided by the JWT match the scopes as required in the API.
func Authenticate(
	jwks keyfunc.Keyfunc,
	permValidator PermValidator,
	ctx context.Context,
	input *openapi3filter.AuthenticationInput,
) error {
	// Our security scheme is named BearerAuth, ensure this is the case
	if input.SecuritySchemeName != "BearerAuth" {
		return AuthError{Message: fmt.Sprintf("security scheme %s != 'BearerAuth'", input.SecuritySchemeName)}
	}

	// Now, we need to get the JWS from the request, to match the request expectations
	// against request contents.
	jws, err := GetJWSFromRequest(input.RequestValidationInput.Request)
	if err != nil {
		return AuthError{Message: fmt.Sprintf("getting jws: %s", err)}
	}

	claims, err := ValidateToken(jws, jwks)
	if err != nil {
		return AuthError{Message: fmt.Sprintf("validating token: %s", err)}
	}

	// Check if token is expired
	if claims.ExpiresAt != nil && claims.ExpiresAt.Time.Before(time.Now()) {
		return AuthError{Message: "token is expired"}
	}

	if len(input.Scopes) != 0 {
		if permValidator != nil {
			//NOTE: can change id to your own id
			valid, err := permValidator.CheckPermission(ctx, claims.Username, input.Scopes)
			if err != nil {
				return AuthError{Message: fmt.Sprintf("check permission: %s", err)}
			}

			if !valid {
				return AuthError{Message: ErrrPermissionDenied.Error()}
			}
		}
	}

	eCtx := middleware.GetEchoContext(ctx)
	eCtx.Set(JWTClaimsContextKey, claims)

	return nil
}
